### [개요]

Unity Dots를 공부하기 위한 프로젝트입니다.
FPS장르로 만들었으며 간단한 캐릭터 이동, 총알 발사, 기존 유니티 모노비헤이비어와 상호작용이 되는지?, UniRx와 같은 라이브러리가 Dots와 어울리는지?, Dots를 사용하면서 디버깅 방법 등
이 프로젝트는 Dots에 익숙해지기 위함입니다.

### [기술 스택]

Unity3D, Unity6.0, Dots 1.3, UniRx

### [작업 인원]

본인 - 1명

### [Dots]

DOTS 자체는 프리릴리스로 꽤 오래전부터 존재해왔다는 사실은 알고 있었습니다. 이번에 Unity 6가 공개되면서 Unity에서 DOTS를 본격적으로 서포트하고 있는 모습을 보고, 저도 본격적으로 공부해볼까 하는 생각이 들었습니다.

Unity 공식 유튜브 영상에서 URP의 렌더링 패스가 DOP(Data-Oriented Programming) 방식으로 구성되었다는 내용을 본 기억이 있습니다. Unity는 모바일 게임 개발에 강점을 가진 엔진이고, 그만큼 성능 최적화를 중요시하는데, 이는 MonoBehaviour가 CPU 친화적이지 않다는 점에서 비롯된 선택이라는 생각이 들었습니다.

누구나 그렇겠지만, 처음 Unity 6를 설치하고 낯선 DOTS 환경에서 작업을 시작했을 때는 약 2주간은 익숙하지 않아 어려움이 있었습니다. 그러나 마치 OOP를 처음 익힐 때처럼, DOTS의 기초와 본질을 이해하게 되자 "아, 이렇게 구성되어야 하고, 이렇게 동작하는구나. 이런 방식이어서 유리하구나."라는 깨달음을 얻게 되었습니다.

DOTS가 있어서 좋은 점도 있지만, 무엇보다도 MonoBehaviour의 장점과 DOTS를 함께 연계해서 사용할 수 있다는 점이 가장 마음에 들었습니다. 이 프로젝트를 진행하면서 얻은 것은 단순히 기능 구현 능력뿐만 아니라, DOTS를 활용해 Authoring, Component, System을 유연하게 구성하는 방법, 디버깅 방법 등 실무적인 활용법에 대한 감각을 익힌 점입니다.

예를 들어, 프로그래머에게 MonoBehaviour 기반으로 Player 움직임을 만들어보라고 한다면, 어떤 사람은 간단히 컨트롤러를 만들어 Update에서 포지션을 직접 수정할 것이고, 또 어떤 사람은 CharacterController를 기반으로 EnemyController, PlayerController를 나눈 후, IMoveState를 통해 이동 로직을 구현하고, 상태 머신을 만들어 Update에서 동작을 호출할 것입니다. 이처럼 접근 방식은 다양하지만, 결국 모두 MonoBehaviour 위에서 동작하는 구조입니다.

결론적으로, 이 프로젝트를 통해 제가 DOTS를 완벽히 마스터하거나 아주 깊이 있게 파고들었다고 보긴 어렵습니다. 다만, DOTS가 어떤 식으로 구성되어 있고, 어떻게 동작하며, 향후 실무에서 DOTS를 사용할 일이 생긴다면 바로 적용할 수 있을 정도의 이해를 쌓는 데 중점을 두었습니다.

실제로 DOTS는 생각보다 진입 장벽이 높은 편이었고, 짧은 시간 안에 개념을 파악하는 것이 쉽지 않았습니다. 그러나 기본 개념과 구조를 이해한 뒤에는 훨씬 명확하게 동작 원리를 파악할 수 있었고, 그 덕분에 기존의 MonoBehaviour 기반 개발 방식과 비교해가며 DOTS의 효율성과 장점을 체감할 수 있었습니다.

### [캐릭터]

캐릭터의 이동, 상태머신은 유니티의 튜토리얼을 통해 먼저 선행학습 후 소스코드를 저의 게임에 맞게 리팩토링했습니다.

Dots는 SubScene에서 생명주기가 돌아가며 Unity의 대부분 컴퍼넌트를 지원하지 않습니다.
제가 사용한 에셋은 Skinned Mesh Renderer를 사용하고 있었고 이 또한 SubScene에서는 렌더링 되지 않습니다.
그렇기에 사용한 방법이 SubScene에는 빈 오브젝트만 두고 World에 해당 프리팹을 생성해서 둘이 동기화시키면 좋을거같다.
라는 생각을 하였고 그런 방식으로 찾아 본 결과 많은 사람들이 Hybrid로 이미 사용을 하고 있다는것을 알았습니다.

그래서 어디까지 Hybrid로 사용해야하냐? 라는 의문점이 들었고 저는 애니메이터를 Dots, World에서 모두 실행시켜보았습니다.
Dots에서는 상태에 따라 애니메이터의 파라미터를 변경시켰으며, World에서는 PlayerPresenter를 생성하여 Model의 리액티브프로퍼티를 통하여 플레이어가 무기를 스왑할때의 애니메이션을 실행시켰습니다.
사용 후 내린 결론은 단일 객체의 일부 시스템은 모노비헤이비어에서은 빈 프로젝트에 에셋만 동일하게 하였습니다. 

총 500마리의 Enemy를 소환하였으며,
Dots 사용 X 버전에서는 NavMeshAgent에 setdestination만 적용하였고
Dots 사용 O 버전에서는 현재 이 프로젝트 모든 기능들이 돌아가게하였습니다.

#### 1. Dots 사용 X
![1](https://github.com/user-attachments/assets/d1d78393-8265-49aa-8940-4b36ae04aab5)

#### 2. Dots 사용 O
![2](https://github.com/user-attachments/assets/03316b77-3868-42a6-8b27-516acf765dcf)

### [결론]

아직 World에 의존하는게 많았으며 프로파일링결과 SystemBase, ISystem등 Job System을 쓰지않는경우 메인쓰레드에서 작동됩니다. ( UnityEngine에서 제공되는 Debug사용가능 )
생성형 AI가 최신 Dots는 학습하지않아 틀린답만 알려줍니다. (제가 이용을 못했던거일수도있습니다.) 구글링을 해도 예전 프리릴리스버전의 소스코드가 많습니다. 그래서 Unity 공식 도큐먼트와 튜토리얼을 보면서 익혔고 프로젝트 완성기간이 예상보다 꽤 많이 흘렀습니다.
뱀서라이크나 디펜스 장르의 게임에 아주 잘 어울릴거 같습니다. ( 정확히는 Object 수가 많은 게임 )

[👉 영상 보기 (Google Drive)](https://drive.google.com/file/d/15t-qNoPYVByihcpjAVcG3qwwRKJPItw9/view?usp=sharing)
